//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.12.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Linq;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using JetBrains.Annotations;

using JetBrains.Core;
using JetBrains.Diagnostics;
using JetBrains.Collections;
using JetBrains.Collections.Viewable;
using JetBrains.Lifetimes;
using JetBrains.Serialization;
using JetBrains.Rd;
using JetBrains.Rd.Base;
using JetBrains.Rd.Impl;
using JetBrains.Rd.Tasks;
using JetBrains.Rd.Util;
using JetBrains.Rd.Text;


// ReSharper disable RedundantEmptyObjectCreationArgumentList
// ReSharper disable InconsistentNaming
// ReSharper disable RedundantOverflowCheckingContext


namespace JetBrains.Rider.Model
{
  
  
  /// <summary>
  /// <p>Generated from: Model.kt:20</p>
  /// </summary>
  public class DemoModel : RdExtBase
  {
    //fields
    //public fields
    [NotNull] public IViewableProperty<bool> Boolean_property => _Boolean_property;
    [NotNull] public IViewableProperty<bool[]> Boolean_array => _Boolean_array;
    [NotNull] public IViewableProperty<MyScalar> Scalar => _Scalar;
    [NotNull] public IViewableProperty<byte> Ubyte => _Ubyte;
    [NotNull] public IViewableProperty<byte[]> Ubyte_array => _Ubyte_array;
    [NotNull] public IViewableList<int> List => _List;
    [NotNull] public IViewableSet<int> Set => _Set;
    [NotNull] public IViewableMap<long, string> MapLongToString => _MapLongToString;
    [NotNull] public IRdEndpoint<char, string> Call => _Call;
    [NotNull] public IRdCall<string, int> Callback => _Callback;
    [NotNull] public IViewableProperty<string> Interned_string => _Interned_string;
    [NotNull] public IViewableProperty<Base> Polymorphic => _Polymorphic;
    [NotNull] public IViewableProperty<OpenDerived> Polymorphic_open => _Polymorphic_open;
    [NotNull] public IViewableProperty<DateTime> Date => _Date;
    [NotNull] public IViewableProperty<TimeSpan> Duration => _Duration;
    [NotNull] public IViewableProperty<string> Property_with_default => _Property_with_default;
    [NotNull] public IViewableProperty<Class> If => _If;
    [NotNull] public IViewableProperty<List<MyScalar>> My_scalars => _My_scalars;
    [NotNull] public IViewableProperty<List<Derived>> List_of_derived => _List_of_derived;
    [NotNull] public IViewableProperty<List<Base>> List_of_base => _List_of_base;
    [NotNull] public IViewableProperty<StructWithOpenStructField> Struct_with_open_field => _Struct_with_open_field;
    [NotNull] public IViewableList<ClassWithExt> ExtList => _ExtList;
    
    //private fields
    [NotNull] private readonly RdProperty<bool> _Boolean_property;
    [NotNull] private readonly RdProperty<bool[]> _Boolean_array;
    [NotNull] private readonly RdProperty<MyScalar> _Scalar;
    [NotNull] private readonly RdProperty<byte> _Ubyte;
    [NotNull] private readonly RdProperty<byte[]> _Ubyte_array;
    [NotNull] private readonly RdList<int> _List;
    [NotNull] private readonly RdSet<int> _Set;
    [NotNull] private readonly RdMap<long, string> _MapLongToString;
    [NotNull] private readonly RdCall<char, string> _Call;
    [NotNull] private readonly RdCall<string, int> _Callback;
    [NotNull] private readonly RdProperty<string> _Interned_string;
    [NotNull] private readonly RdProperty<Base> _Polymorphic;
    [NotNull] private readonly RdProperty<OpenDerived> _Polymorphic_open;
    [NotNull] private readonly RdProperty<DateTime> _Date;
    [NotNull] private readonly RdProperty<TimeSpan> _Duration;
    [NotNull] private readonly RdProperty<string> _Property_with_default;
    [NotNull] private readonly RdProperty<Class> _If;
    [NotNull] private readonly RdProperty<List<MyScalar>> _My_scalars;
    [NotNull] private readonly RdProperty<List<Derived>> _List_of_derived;
    [NotNull] private readonly RdProperty<List<Base>> _List_of_base;
    [NotNull] private readonly RdProperty<StructWithOpenStructField> _Struct_with_open_field;
    [NotNull] private readonly RdList<ClassWithExt> _ExtList;
    
    //primary constructor
    private DemoModel(
      [NotNull] RdProperty<bool> boolean_property,
      [NotNull] RdProperty<bool[]> boolean_array,
      [NotNull] RdProperty<MyScalar> scalar,
      [NotNull] RdProperty<byte> ubyte,
      [NotNull] RdProperty<byte[]> ubyte_array,
      [NotNull] RdList<int> list,
      [NotNull] RdSet<int> set,
      [NotNull] RdMap<long, string> mapLongToString,
      [NotNull] RdCall<char, string> call,
      [NotNull] RdCall<string, int> callback,
      [NotNull] RdProperty<string> interned_string,
      [NotNull] RdProperty<Base> polymorphic,
      [NotNull] RdProperty<OpenDerived> polymorphic_open,
      [NotNull] RdProperty<DateTime> date,
      [NotNull] RdProperty<TimeSpan> duration,
      [NotNull] RdProperty<string> property_with_default,
      [NotNull] RdProperty<Class> @if,
      [NotNull] RdProperty<List<MyScalar>> my_scalars,
      [NotNull] RdProperty<List<Derived>> list_of_derived,
      [NotNull] RdProperty<List<Base>> list_of_base,
      [NotNull] RdProperty<StructWithOpenStructField> struct_with_open_field,
      [NotNull] RdList<ClassWithExt> extList
    )
    {
      if (boolean_property == null) throw new ArgumentNullException("boolean_property");
      if (boolean_array == null) throw new ArgumentNullException("boolean_array");
      if (scalar == null) throw new ArgumentNullException("scalar");
      if (ubyte == null) throw new ArgumentNullException("ubyte");
      if (ubyte_array == null) throw new ArgumentNullException("ubyte_array");
      if (list == null) throw new ArgumentNullException("list");
      if (set == null) throw new ArgumentNullException("set");
      if (mapLongToString == null) throw new ArgumentNullException("mapLongToString");
      if (call == null) throw new ArgumentNullException("call");
      if (callback == null) throw new ArgumentNullException("callback");
      if (interned_string == null) throw new ArgumentNullException("interned_string");
      if (polymorphic == null) throw new ArgumentNullException("polymorphic");
      if (polymorphic_open == null) throw new ArgumentNullException("polymorphic_open");
      if (date == null) throw new ArgumentNullException("date");
      if (duration == null) throw new ArgumentNullException("duration");
      if (property_with_default == null) throw new ArgumentNullException("property_with_default");
      if (@if == null) throw new ArgumentNullException("if");
      if (my_scalars == null) throw new ArgumentNullException("my_scalars");
      if (list_of_derived == null) throw new ArgumentNullException("list_of_derived");
      if (list_of_base == null) throw new ArgumentNullException("list_of_base");
      if (struct_with_open_field == null) throw new ArgumentNullException("struct_with_open_field");
      if (extList == null) throw new ArgumentNullException("extList");
      
      _Boolean_property = boolean_property;
      _Boolean_array = boolean_array;
      _Scalar = scalar;
      _Ubyte = ubyte;
      _Ubyte_array = ubyte_array;
      _List = list;
      _Set = set;
      _MapLongToString = mapLongToString;
      _Call = call;
      _Callback = callback;
      _Interned_string = interned_string;
      _Polymorphic = polymorphic;
      _Polymorphic_open = polymorphic_open;
      _Date = date;
      _Duration = duration;
      _Property_with_default = property_with_default;
      _If = @if;
      _My_scalars = my_scalars;
      _List_of_derived = list_of_derived;
      _List_of_base = list_of_base;
      _Struct_with_open_field = struct_with_open_field;
      _ExtList = extList;
      _Boolean_property.OptimizeNested = true;
      _Boolean_array.OptimizeNested = true;
      _Scalar.OptimizeNested = true;
      _Ubyte.OptimizeNested = true;
      _Ubyte_array.OptimizeNested = true;
      _List.OptimizeNested = true;
      _Set.OptimizeNested = true;
      _MapLongToString.OptimizeNested = true;
      _Interned_string.OptimizeNested = true;
      _Polymorphic.OptimizeNested = true;
      _Polymorphic_open.OptimizeNested = true;
      _Date.OptimizeNested = true;
      _Duration.OptimizeNested = true;
      _Property_with_default.OptimizeNested = true;
      _If.OptimizeNested = true;
      _My_scalars.OptimizeNested = true;
      _List_of_derived.OptimizeNested = true;
      _List_of_base.OptimizeNested = true;
      _Struct_with_open_field.OptimizeNested = true;
      BindableChildren.Add(new KeyValuePair<string, object>("boolean_property", _Boolean_property));
      BindableChildren.Add(new KeyValuePair<string, object>("boolean_array", _Boolean_array));
      BindableChildren.Add(new KeyValuePair<string, object>("scalar", _Scalar));
      BindableChildren.Add(new KeyValuePair<string, object>("ubyte", _Ubyte));
      BindableChildren.Add(new KeyValuePair<string, object>("ubyte_array", _Ubyte_array));
      BindableChildren.Add(new KeyValuePair<string, object>("list", _List));
      BindableChildren.Add(new KeyValuePair<string, object>("set", _Set));
      BindableChildren.Add(new KeyValuePair<string, object>("mapLongToString", _MapLongToString));
      BindableChildren.Add(new KeyValuePair<string, object>("call", _Call));
      BindableChildren.Add(new KeyValuePair<string, object>("callback", _Callback));
      BindableChildren.Add(new KeyValuePair<string, object>("interned_string", _Interned_string));
      BindableChildren.Add(new KeyValuePair<string, object>("polymorphic", _Polymorphic));
      BindableChildren.Add(new KeyValuePair<string, object>("polymorphic_open", _Polymorphic_open));
      BindableChildren.Add(new KeyValuePair<string, object>("date", _Date));
      BindableChildren.Add(new KeyValuePair<string, object>("duration", _Duration));
      BindableChildren.Add(new KeyValuePair<string, object>("property_with_default", _Property_with_default));
      BindableChildren.Add(new KeyValuePair<string, object>("if", _If));
      BindableChildren.Add(new KeyValuePair<string, object>("my_scalars", _My_scalars));
      BindableChildren.Add(new KeyValuePair<string, object>("list_of_derived", _List_of_derived));
      BindableChildren.Add(new KeyValuePair<string, object>("list_of_base", _List_of_base));
      BindableChildren.Add(new KeyValuePair<string, object>("struct_with_open_field", _Struct_with_open_field));
      BindableChildren.Add(new KeyValuePair<string, object>("extList", _ExtList));
    }
    //secondary constructor
    private DemoModel (
    ) : this (
      new RdProperty<bool>(JetBrains.Rd.Impl.Serializers.ReadBool, JetBrains.Rd.Impl.Serializers.WriteBool),
      new RdProperty<bool[]>(JetBrains.Rd.Impl.Serializers.ReadBoolArray, JetBrains.Rd.Impl.Serializers.WriteBoolArray),
      new RdProperty<MyScalar>(MyScalar.Read, MyScalar.Write),
      new RdProperty<byte>(JetBrains.Rd.Impl.Serializers.ReadUByte, JetBrains.Rd.Impl.Serializers.WriteUByte),
      new RdProperty<byte[]>(ReadUByteArray, WriteUByteArray),
      new RdList<int>(JetBrains.Rd.Impl.Serializers.ReadInt, JetBrains.Rd.Impl.Serializers.WriteInt),
      new RdSet<int>(JetBrains.Rd.Impl.Serializers.ReadInt, JetBrains.Rd.Impl.Serializers.WriteInt),
      new RdMap<long, string>(JetBrains.Rd.Impl.Serializers.ReadLong, JetBrains.Rd.Impl.Serializers.WriteLong, JetBrains.Rd.Impl.Serializers.ReadString, JetBrains.Rd.Impl.Serializers.WriteString),
      new RdCall<char, string>(JetBrains.Rd.Impl.Serializers.ReadChar, JetBrains.Rd.Impl.Serializers.WriteChar, JetBrains.Rd.Impl.Serializers.ReadString, JetBrains.Rd.Impl.Serializers.WriteString),
      new RdCall<string, int>(JetBrains.Rd.Impl.Serializers.ReadString, JetBrains.Rd.Impl.Serializers.WriteString, JetBrains.Rd.Impl.Serializers.ReadInt, JetBrains.Rd.Impl.Serializers.WriteInt),
      new RdProperty<string>(ReadStringInternedAtProtocol, WriteStringInternedAtProtocol),
      new RdProperty<Base>(Base.Read, Base.Write),
      new RdProperty<OpenDerived>(ReadOpenDerived, WriteOpenDerived),
      new RdProperty<DateTime>(JetBrains.Rd.Impl.Serializers.ReadDateTime, JetBrains.Rd.Impl.Serializers.WriteDateTime),
      new RdProperty<TimeSpan>(JetBrains.Rd.Impl.Serializers.ReadTimeSpan, JetBrains.Rd.Impl.Serializers.WriteTimeSpan),
      new RdProperty<string>(JetBrains.Rd.Impl.Serializers.ReadString, JetBrains.Rd.Impl.Serializers.WriteString, const_for_default),
      new RdProperty<Class>(Class.Read, Class.Write),
      new RdProperty<List<MyScalar>>(ReadMyScalarList, WriteMyScalarList),
      new RdProperty<List<Derived>>(ReadDerivedList, WriteDerivedList),
      new RdProperty<List<Base>>(ReadBaseList, WriteBaseList),
      new RdProperty<StructWithOpenStructField>(StructWithOpenStructField.Read, StructWithOpenStructField.Write),
      new RdList<ClassWithExt>(ClassWithExt.Read, ClassWithExt.Write)
    ) {}
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<byte[]> ReadUByteArray = JetBrains.Rd.Impl.Serializers.ReadUByte.Array();
    public static CtxReadDelegate<string> ReadStringInternedAtProtocol = JetBrains.Rd.Impl.Serializers.ReadString.Interned("Protocol");
    public static CtxReadDelegate<OpenDerived> ReadOpenDerived = Polymorphic<OpenDerived>.ReadAbstract(OpenDerived_Unknown.Read);
    public static CtxReadDelegate<List<MyScalar>> ReadMyScalarList = MyScalar.Read.List();
    public static CtxReadDelegate<List<Derived>> ReadDerivedList = Derived.Read.List();
    public static CtxReadDelegate<List<Base>> ReadBaseList = Base.Read.List();
    
    public static  CtxWriteDelegate<byte[]> WriteUByteArray = JetBrains.Rd.Impl.Serializers.WriteUByte.Array();
    public static  CtxWriteDelegate<string> WriteStringInternedAtProtocol = JetBrains.Rd.Impl.Serializers.WriteString.Interned("Protocol");
    public static  CtxWriteDelegate<OpenDerived> WriteOpenDerived = Polymorphic<OpenDerived>.Write;
    public static  CtxWriteDelegate<List<MyScalar>> WriteMyScalarList = MyScalar.Write.List();
    public static  CtxWriteDelegate<List<Derived>> WriteDerivedList = Derived.Write.List();
    public static  CtxWriteDelegate<List<Base>> WriteBaseList = Base.Write.List();
    
    protected override long SerializationHash => 4763670262278714493L;
    
    protected override Action<ISerializers> Register => RegisterDeclaredTypesSerializers;
    public static void RegisterDeclaredTypesSerializers(ISerializers serializers)
    {
      serializers.Register(OpenClass.Read, OpenClass.Write);
      serializers.Register(Derived.Read, Derived.Write);
      serializers.Register(Open.Read, Open.Write);
      serializers.Register(OpenDerived.Read, OpenDerived.Write);
      serializers.Register(OpenStructInField.Read, OpenStructInField.Write);
      serializers.Register(Base_Unknown.Read, Base_Unknown.Write);
      serializers.Register(OpenClass_Unknown.Read, OpenClass_Unknown.Write);
      serializers.Register(Open_Unknown.Read, Open_Unknown.Write);
      serializers.Register(OpenDerived_Unknown.Read, OpenDerived_Unknown.Write);
      serializers.Register(OpenStructInField_Unknown.Read, OpenStructInField_Unknown.Write);
      
      serializers.RegisterToplevelOnce(typeof(DemoRoot), DemoRoot.RegisterDeclaredTypesSerializers);
    }
    
    public DemoModel(Lifetime lifetime, IProtocol protocol) : this()
    {
      Identify(protocol.Identities, RdId.Root.Mix("DemoModel"));
      this.BindTopLevel(lifetime, protocol, "DemoModel");
    }
    
    //constants
    public const bool const_toplevel = true;
    public const string const_for_default = "192";
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("DemoModel (");
      using (printer.IndentCookie()) {
        printer.Print("boolean_property = "); _Boolean_property.PrintEx(printer); printer.Println();
        printer.Print("boolean_array = "); _Boolean_array.PrintEx(printer); printer.Println();
        printer.Print("scalar = "); _Scalar.PrintEx(printer); printer.Println();
        printer.Print("ubyte = "); _Ubyte.PrintEx(printer); printer.Println();
        printer.Print("ubyte_array = "); _Ubyte_array.PrintEx(printer); printer.Println();
        printer.Print("list = "); _List.PrintEx(printer); printer.Println();
        printer.Print("set = "); _Set.PrintEx(printer); printer.Println();
        printer.Print("mapLongToString = "); _MapLongToString.PrintEx(printer); printer.Println();
        printer.Print("call = "); _Call.PrintEx(printer); printer.Println();
        printer.Print("callback = "); _Callback.PrintEx(printer); printer.Println();
        printer.Print("interned_string = "); _Interned_string.PrintEx(printer); printer.Println();
        printer.Print("polymorphic = "); _Polymorphic.PrintEx(printer); printer.Println();
        printer.Print("polymorphic_open = "); _Polymorphic_open.PrintEx(printer); printer.Println();
        printer.Print("date = "); _Date.PrintEx(printer); printer.Println();
        printer.Print("duration = "); _Duration.PrintEx(printer); printer.Println();
        printer.Print("property_with_default = "); _Property_with_default.PrintEx(printer); printer.Println();
        printer.Print("if = "); _If.PrintEx(printer); printer.Println();
        printer.Print("my_scalars = "); _My_scalars.PrintEx(printer); printer.Println();
        printer.Print("list_of_derived = "); _List_of_derived.PrintEx(printer); printer.Println();
        printer.Print("list_of_base = "); _List_of_base.PrintEx(printer); printer.Println();
        printer.Print("struct_with_open_field = "); _Struct_with_open_field.PrintEx(printer); printer.Println();
        printer.Print("extList = "); _ExtList.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: Model.kt:53</p>
  /// </summary>
  public abstract class Base{
    //fields
    //public fields
    
    //private fields
    //primary constructor
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<Base> Read = Polymorphic<Base>.ReadAbstract(Base_Unknown.Read);
    
    public static CtxWriteDelegate<Base> Write = Polymorphic<Base>.Write;
    
    //constants
    public const char const_base = 'B';
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class Base_Unknown : Base
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<Base_Unknown> Read = (ctx, reader) => 
    {
      var _result = new Base_Unknown();
      return _result;
    };
    
    public static new CtxWriteDelegate<Base_Unknown> Write = (ctx, writer, value) => 
    {
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((Base_Unknown) obj);
    }
    public bool Equals(Base_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return true;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("Base_Unknown (");
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: Model.kt:21</p>
  /// </summary>
  public sealed class Class : IPrintable, IEquatable<Class>
  {
    //fields
    //public fields
    [NotNull] public string True {get; private set;}
    
    //private fields
    //primary constructor
    public Class(
      [NotNull] string @true
    )
    {
      if (@true == null) throw new ArgumentNullException("true");
      
      True = @true;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string @true)
    {
      @true = True;
    }
    //statics
    
    public static CtxReadDelegate<Class> Read = (ctx, reader) => 
    {
      var @true = reader.ReadString();
      var _result = new Class(@true);
      return _result;
    };
    
    public static CtxWriteDelegate<Class> Write = (ctx, writer, value) => 
    {
      writer.Write(value.True);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((Class) obj);
    }
    public bool Equals(Class other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return True == other.True;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + True.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("Class (");
      using (printer.IndentCookie()) {
        printer.Print("true = "); True.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: Model.kt:91</p>
  /// </summary>
  public sealed class ClassWithExt : RdBindableBase
  {
    //fields
    //public fields
    public int Key {get; private set;}
    
    //private fields
    //primary constructor
    public ClassWithExt(
      int key
    )
    {
      Key = key;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<ClassWithExt> Read = (ctx, reader) => 
    {
      var _id = RdId.Read(reader);
      var key = reader.ReadInt();
      var _result = new ClassWithExt(key).WithId(_id);
      return _result;
    };
    
    public static CtxWriteDelegate<ClassWithExt> Write = (ctx, writer, value) => 
    {
      value.RdId.Write(writer);
      writer.Write(value.Key);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("ClassWithExt (");
      using (printer.IndentCookie()) {
        printer.Print("key = "); Key.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: Model.kt:95</p>
  /// </summary>
  public sealed class ClassWithStructArrayField : RdBindableBase
  {
    //fields
    //public fields
    [NotNull] public MyScalar[] ArrayField {get; private set;}
    
    //private fields
    //primary constructor
    public ClassWithStructArrayField(
      [NotNull] MyScalar[] arrayField
    )
    {
      if (arrayField == null) throw new ArgumentNullException("arrayField");
      
      ArrayField = arrayField;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<ClassWithStructArrayField> Read = (ctx, reader) => 
    {
      var _id = RdId.Read(reader);
      var arrayField = ReadMyScalarArray(ctx, reader);
      var _result = new ClassWithStructArrayField(arrayField).WithId(_id);
      return _result;
    };
    public static CtxReadDelegate<MyScalar[]> ReadMyScalarArray = MyScalar.Read.Array();
    
    public static CtxWriteDelegate<ClassWithStructArrayField> Write = (ctx, writer, value) => 
    {
      value.RdId.Write(writer);
      WriteMyScalarArray(ctx, writer, value.ArrayField);
    };
    public static  CtxWriteDelegate<MyScalar[]> WriteMyScalarArray = MyScalar.Write.Array();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("ClassWithStructArrayField (");
      using (printer.IndentCookie()) {
        printer.Print("arrayField = "); ArrayField.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: Model.kt:84</p>
  /// </summary>
  public sealed class ComplicatedPair : IPrintable, IEquatable<ComplicatedPair>
  {
    //fields
    //public fields
    [NotNull] public Derived First {get; private set;}
    [NotNull] public Derived Second {get; private set;}
    
    //private fields
    //primary constructor
    public ComplicatedPair(
      [NotNull] Derived first,
      [NotNull] Derived second
    )
    {
      if (first == null) throw new ArgumentNullException("first");
      if (second == null) throw new ArgumentNullException("second");
      
      First = first;
      Second = second;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out Derived first, [NotNull] out Derived second)
    {
      first = First;
      second = Second;
    }
    //statics
    
    public static CtxReadDelegate<ComplicatedPair> Read = (ctx, reader) => 
    {
      var first = Derived.Read(ctx, reader);
      var second = Derived.Read(ctx, reader);
      var _result = new ComplicatedPair(first, second);
      return _result;
    };
    
    public static CtxWriteDelegate<ComplicatedPair> Write = (ctx, writer, value) => 
    {
      Derived.Write(ctx, writer, value.First);
      Derived.Write(ctx, writer, value.Second);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((ComplicatedPair) obj);
    }
    public bool Equals(ComplicatedPair other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(First, other.First) && Equals(Second, other.Second);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + First.GetHashCode();
        hash = hash * 31 + Second.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("ComplicatedPair (");
      using (printer.IndentCookie()) {
        printer.Print("first = "); First.PrintEx(printer); printer.Println();
        printer.Print("second = "); Second.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: Model.kt:39</p>
  /// </summary>
  public sealed class ConstUtil : IPrintable, IEquatable<ConstUtil>
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<ConstUtil> Read = (ctx, reader) => 
    {
      var _result = new ConstUtil();
      return _result;
    };
    
    public static CtxWriteDelegate<ConstUtil> Write = (ctx, writer, value) => 
    {
    };
    
    //constants
    public const byte const_byte = 0;
    public const short const_short = 32767;
    public const int const_int = 2147483647;
    public const long const_long = 9223372036854775807L;
    public const byte const_ubyte = 255;
    public const ushort const_ushort = 65535;
    public const uint const_uint = 4294967295U;
    public const ulong const_ulong = 18446744073709551615UL;
    public const float const_float = 0.0F;
    public const double const_double = 0.0;
    public const string const_string = "const_string_value";
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((ConstUtil) obj);
    }
    public bool Equals(ConstUtil other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return true;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("ConstUtil (");
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: Model.kt:62</p>
  /// </summary>
  public sealed class Derived : Base
  {
    //fields
    //public fields
    [NotNull] public string String {get; private set;}
    
    //private fields
    //primary constructor
    public Derived(
      [NotNull] string @string
    )
    {
      if (@string == null) throw new ArgumentNullException("string");
      
      String = @string;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<Derived> Read = (ctx, reader) => 
    {
      var @string = reader.ReadString();
      var _result = new Derived(@string);
      return _result;
    };
    
    public static new CtxWriteDelegate<Derived> Write = (ctx, writer, value) => 
    {
      writer.Write(value.String);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((Derived) obj);
    }
    public bool Equals(Derived other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return String == other.String;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + String.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("Derived (");
      using (printer.IndentCookie()) {
        printer.Print("string = "); String.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: Model.kt:25</p>
  /// </summary>
  public sealed class MyScalar : IPrintable, IEquatable<MyScalar>
  {
    //fields
    //public fields
    public bool Bool {get; private set;}
    public byte Byte {get; private set;}
    public short Short {get; private set;}
    public int Int {get; private set;}
    public long Long {get; private set;}
    public float Float {get; private set;}
    public double Double {get; private set;}
    public byte Unsigned_byte {get; private set;}
    public ushort Unsigned_short {get; private set;}
    public uint Unsigned_int {get; private set;}
    public ulong Unsigned_long {get; private set;}
    
    //private fields
    //primary constructor
    public MyScalar(
      bool @bool,
      byte @byte,
      short @short,
      int @int,
      long @long,
      float @float,
      double @double,
      byte unsigned_byte,
      ushort unsigned_short,
      uint unsigned_int,
      ulong unsigned_long
    )
    {
      Bool = @bool;
      Byte = @byte;
      Short = @short;
      Int = @int;
      Long = @long;
      Float = @float;
      Double = @double;
      Unsigned_byte = unsigned_byte;
      Unsigned_short = unsigned_short;
      Unsigned_int = unsigned_int;
      Unsigned_long = unsigned_long;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out bool @bool, out byte @byte, out short @short, out int @int, out long @long, out float @float, out double @double, out byte unsigned_byte, out ushort unsigned_short, out uint unsigned_int, out ulong unsigned_long)
    {
      @bool = Bool;
      @byte = Byte;
      @short = Short;
      @int = Int;
      @long = Long;
      @float = Float;
      @double = Double;
      unsigned_byte = Unsigned_byte;
      unsigned_short = Unsigned_short;
      unsigned_int = Unsigned_int;
      unsigned_long = Unsigned_long;
    }
    //statics
    
    public static CtxReadDelegate<MyScalar> Read = (ctx, reader) => 
    {
      var @bool = reader.ReadBool();
      var @byte = reader.ReadByte();
      var @short = reader.ReadShort();
      var @int = reader.ReadInt();
      var @long = reader.ReadLong();
      var @float = reader.ReadFloat();
      var @double = reader.ReadDouble();
      var unsigned_byte = reader.ReadUByte();
      var unsigned_short = reader.ReadUShort();
      var unsigned_int = reader.ReadUInt();
      var unsigned_long = reader.ReadULong();
      var _result = new MyScalar(@bool, @byte, @short, @int, @long, @float, @double, unsigned_byte, unsigned_short, unsigned_int, unsigned_long);
      return _result;
    };
    
    public static CtxWriteDelegate<MyScalar> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Bool);
      writer.Write(value.Byte);
      writer.Write(value.Short);
      writer.Write(value.Int);
      writer.Write(value.Long);
      writer.Write(value.Float);
      writer.Write(value.Double);
      writer.Write(value.Unsigned_byte);
      writer.Write(value.Unsigned_short);
      writer.Write(value.Unsigned_int);
      writer.Write(value.Unsigned_long);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((MyScalar) obj);
    }
    public bool Equals(MyScalar other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Bool == other.Bool && Byte == other.Byte && Short == other.Short && Int == other.Int && Long == other.Long && Float == other.Float && Double == other.Double && Unsigned_byte == other.Unsigned_byte && Unsigned_short == other.Unsigned_short && Unsigned_int == other.Unsigned_int && Unsigned_long == other.Unsigned_long;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Bool.GetHashCode();
        hash = hash * 31 + Byte.GetHashCode();
        hash = hash * 31 + Short.GetHashCode();
        hash = hash * 31 + Int.GetHashCode();
        hash = hash * 31 + Long.GetHashCode();
        hash = hash * 31 + Float.GetHashCode();
        hash = hash * 31 + Double.GetHashCode();
        hash = hash * 31 + Unsigned_byte.GetHashCode();
        hash = hash * 31 + Unsigned_short.GetHashCode();
        hash = hash * 31 + Unsigned_int.GetHashCode();
        hash = hash * 31 + Unsigned_long.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("MyScalar (");
      using (printer.IndentCookie()) {
        printer.Print("bool = "); Bool.PrintEx(printer); printer.Println();
        printer.Print("byte = "); Byte.PrintEx(printer); printer.Println();
        printer.Print("short = "); Short.PrintEx(printer); printer.Println();
        printer.Print("int = "); Int.PrintEx(printer); printer.Println();
        printer.Print("long = "); Long.PrintEx(printer); printer.Println();
        printer.Print("float = "); Float.PrintEx(printer); printer.Println();
        printer.Print("double = "); Double.PrintEx(printer); printer.Println();
        printer.Print("unsigned_byte = "); Unsigned_byte.PrintEx(printer); printer.Println();
        printer.Print("unsigned_short = "); Unsigned_short.PrintEx(printer); printer.Println();
        printer.Print("unsigned_int = "); Unsigned_int.PrintEx(printer); printer.Println();
        printer.Print("unsigned_long = "); Unsigned_long.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: Model.kt:66</p>
  /// </summary>
  public class Open : Base
  {
    //fields
    //public fields
    [NotNull] public string OpenString {get; private set;}
    
    //private fields
    //primary constructor
    public Open(
      [NotNull] string openString
    )
    {
      if (openString == null) throw new ArgumentNullException("openString");
      
      OpenString = openString;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<Open> Read = (ctx, reader) => 
    {
      var openString = reader.ReadString();
      var _result = new Open(openString);
      return _result;
    };
    
    public static new CtxWriteDelegate<Open> Write = (ctx, writer, value) => 
    {
      writer.Write(value.OpenString);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((Open) obj);
    }
    public bool Equals(Open other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return OpenString == other.OpenString;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + OpenString.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public virtual void Print(PrettyPrinter printer)
    {
      printer.Println("Open (");
      using (printer.IndentCookie()) {
        printer.Print("openString = "); OpenString.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: Model.kt:57</p>
  /// </summary>
  public class OpenClass : RdBindableBase
  {
    //fields
    //public fields
    [NotNull] public IViewableProperty<string> String => _String;
    [NotNull] public string Field {get; private set;}
    
    //private fields
    [NotNull] protected readonly RdProperty<string> _String;
    
    //primary constructor
    protected OpenClass(
      [NotNull] RdProperty<string> @string,
      [NotNull] string field
    )
    {
      if (@string == null) throw new ArgumentNullException("string");
      if (field == null) throw new ArgumentNullException("field");
      
      _String = @string;
      Field = field;
      _String.OptimizeNested = true;
      BindableChildren.Add(new KeyValuePair<string, object>("string", _String));
    }
    //secondary constructor
    public OpenClass (
      [NotNull] string field
    ) : this (
      new RdProperty<string>(JetBrains.Rd.Impl.Serializers.ReadString, JetBrains.Rd.Impl.Serializers.WriteString),
      field
    ) {}
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<OpenClass> Read = (ctx, reader) => 
    {
      var _id = RdId.Read(reader);
      var @string = RdProperty<string>.Read(ctx, reader, JetBrains.Rd.Impl.Serializers.ReadString, JetBrains.Rd.Impl.Serializers.WriteString);
      var field = reader.ReadString();
      var _result = new OpenClass(@string, field).WithId(_id);
      return _result;
    };
    
    public static CtxWriteDelegate<OpenClass> Write = (ctx, writer, value) => 
    {
      value.RdId.Write(writer);
      RdProperty<string>.Write(ctx, writer, value._String);
      writer.Write(value.Field);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("OpenClass (");
      using (printer.IndentCookie()) {
        printer.Print("string = "); _String.PrintEx(printer); printer.Println();
        printer.Print("field = "); Field.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  public sealed class OpenClass_Unknown : OpenClass
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    private OpenClass_Unknown(
      [NotNull] RdProperty<string> @string,
      [NotNull] string field
    ) : base (
      @string,
      field
     ) 
    {
    }
    //secondary constructor
    public OpenClass_Unknown (
      [NotNull] string field
    ) : this (
      new RdProperty<string>(JetBrains.Rd.Impl.Serializers.ReadString, JetBrains.Rd.Impl.Serializers.WriteString),
      field
    ) {}
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<OpenClass_Unknown> Read = (ctx, reader) => 
    {
      var _id = RdId.Read(reader);
      var @string = RdProperty<string>.Read(ctx, reader, JetBrains.Rd.Impl.Serializers.ReadString, JetBrains.Rd.Impl.Serializers.WriteString);
      var field = reader.ReadString();
      var _result = new OpenClass_Unknown(@string, field).WithId(_id);
      return _result;
    };
    
    public static new CtxWriteDelegate<OpenClass_Unknown> Write = (ctx, writer, value) => 
    {
      value.RdId.Write(writer);
      RdProperty<string>.Write(ctx, writer, value._String);
      writer.Write(value.Field);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("OpenClass_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("string = "); _String.PrintEx(printer); printer.Println();
        printer.Print("field = "); Field.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: Model.kt:70</p>
  /// </summary>
  public class OpenDerived : Open
  {
    //fields
    //public fields
    [NotNull] public string OpenDerivedString {get; private set;}
    
    //private fields
    //primary constructor
    public OpenDerived(
      [NotNull] string openDerivedString,
      [NotNull] string openString
    ) : base (
      openString
     ) 
    {
      if (openDerivedString == null) throw new ArgumentNullException("openDerivedString");
      
      OpenDerivedString = openDerivedString;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<OpenDerived> Read = (ctx, reader) => 
    {
      var openString = reader.ReadString();
      var openDerivedString = reader.ReadString();
      var _result = new OpenDerived(openDerivedString, openString);
      return _result;
    };
    
    public static new CtxWriteDelegate<OpenDerived> Write = (ctx, writer, value) => 
    {
      writer.Write(value.OpenString);
      writer.Write(value.OpenDerivedString);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((OpenDerived) obj);
    }
    public bool Equals(OpenDerived other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return OpenDerivedString == other.OpenDerivedString && OpenString == other.OpenString;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + OpenDerivedString.GetHashCode();
        hash = hash * 31 + OpenString.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("OpenDerived (");
      using (printer.IndentCookie()) {
        printer.Print("openDerivedString = "); OpenDerivedString.PrintEx(printer); printer.Println();
        printer.Print("openString = "); OpenString.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  public sealed class OpenDerived_Unknown : OpenDerived
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public OpenDerived_Unknown(
      [NotNull] string openDerivedString,
      [NotNull] string openString
    ) : base (
      openDerivedString,
      openString
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<OpenDerived_Unknown> Read = (ctx, reader) => 
    {
      var openDerivedString = reader.ReadString();
      var openString = reader.ReadString();
      var _result = new OpenDerived_Unknown(openDerivedString, openString);
      return _result;
    };
    
    public static new CtxWriteDelegate<OpenDerived_Unknown> Write = (ctx, writer, value) => 
    {
      writer.Write(value.OpenDerivedString);
      writer.Write(value.OpenString);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((OpenDerived_Unknown) obj);
    }
    public bool Equals(OpenDerived_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return OpenDerivedString == other.OpenDerivedString && OpenString == other.OpenString;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + OpenDerivedString.GetHashCode();
        hash = hash * 31 + OpenString.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("OpenDerived_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("openDerivedString = "); OpenDerivedString.PrintEx(printer); printer.Println();
        printer.Print("openString = "); OpenString.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: Model.kt:75</p>
  /// </summary>
  public class OpenStructInField{
    //fields
    //public fields
    [NotNull] public string Underflow0 {get; private set;}
    [NotNull] public string Underflow1 {get; private set;}
    public int Value {get; private set;}
    [NotNull] public string Overflow0 {get; private set;}
    [NotNull] public string Overflow1 {get; private set;}
    
    //private fields
    //primary constructor
    public OpenStructInField(
      [NotNull] string underflow0,
      [NotNull] string underflow1,
      int value,
      [NotNull] string overflow0,
      [NotNull] string overflow1
    )
    {
      if (underflow0 == null) throw new ArgumentNullException("underflow0");
      if (underflow1 == null) throw new ArgumentNullException("underflow1");
      if (overflow0 == null) throw new ArgumentNullException("overflow0");
      if (overflow1 == null) throw new ArgumentNullException("overflow1");
      
      Underflow0 = underflow0;
      Underflow1 = underflow1;
      Value = value;
      Overflow0 = overflow0;
      Overflow1 = overflow1;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<OpenStructInField> Read = (ctx, reader) => 
    {
      var underflow0 = reader.ReadString();
      var underflow1 = reader.ReadString();
      var value = reader.ReadInt();
      var overflow0 = reader.ReadString();
      var overflow1 = reader.ReadString();
      var _result = new OpenStructInField(underflow0, underflow1, value, overflow0, overflow1);
      return _result;
    };
    
    public static CtxWriteDelegate<OpenStructInField> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Underflow0);
      writer.Write(value.Underflow1);
      writer.Write(value.Value);
      writer.Write(value.Overflow0);
      writer.Write(value.Overflow1);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((OpenStructInField) obj);
    }
    public bool Equals(OpenStructInField other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Underflow0 == other.Underflow0 && Underflow1 == other.Underflow1 && Value == other.Value && Overflow0 == other.Overflow0 && Overflow1 == other.Overflow1;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Underflow0.GetHashCode();
        hash = hash * 31 + Underflow1.GetHashCode();
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Overflow0.GetHashCode();
        hash = hash * 31 + Overflow1.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public virtual void Print(PrettyPrinter printer)
    {
      printer.Println("OpenStructInField (");
      using (printer.IndentCookie()) {
        printer.Print("underflow0 = "); Underflow0.PrintEx(printer); printer.Println();
        printer.Print("underflow1 = "); Underflow1.PrintEx(printer); printer.Println();
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("overflow0 = "); Overflow0.PrintEx(printer); printer.Println();
        printer.Print("overflow1 = "); Overflow1.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  public sealed class OpenStructInField_Unknown : OpenStructInField
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public OpenStructInField_Unknown(
      [NotNull] string underflow0,
      [NotNull] string underflow1,
      int value,
      [NotNull] string overflow0,
      [NotNull] string overflow1
    ) : base (
      underflow0,
      underflow1,
      value,
      overflow0,
      overflow1
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<OpenStructInField_Unknown> Read = (ctx, reader) => 
    {
      var underflow0 = reader.ReadString();
      var underflow1 = reader.ReadString();
      var value = reader.ReadInt();
      var overflow0 = reader.ReadString();
      var overflow1 = reader.ReadString();
      var _result = new OpenStructInField_Unknown(underflow0, underflow1, value, overflow0, overflow1);
      return _result;
    };
    
    public static new CtxWriteDelegate<OpenStructInField_Unknown> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Underflow0);
      writer.Write(value.Underflow1);
      writer.Write(value.Value);
      writer.Write(value.Overflow0);
      writer.Write(value.Overflow1);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((OpenStructInField_Unknown) obj);
    }
    public bool Equals(OpenStructInField_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Underflow0 == other.Underflow0 && Underflow1 == other.Underflow1 && Value == other.Value && Overflow0 == other.Overflow0 && Overflow1 == other.Overflow1;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Underflow0.GetHashCode();
        hash = hash * 31 + Underflow1.GetHashCode();
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Overflow0.GetHashCode();
        hash = hash * 31 + Overflow1.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("OpenStructInField_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("underflow0 = "); Underflow0.PrintEx(printer); printer.Println();
        printer.Print("underflow1 = "); Underflow1.PrintEx(printer); printer.Println();
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("overflow0 = "); Overflow0.PrintEx(printer); printer.Println();
        printer.Print("overflow1 = "); Overflow1.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  public sealed class Open_Unknown : Open
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public Open_Unknown(
      [NotNull] string openString
    ) : base (
      openString
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<Open_Unknown> Read = (ctx, reader) => 
    {
      var openString = reader.ReadString();
      var _result = new Open_Unknown(openString);
      return _result;
    };
    
    public static new CtxWriteDelegate<Open_Unknown> Write = (ctx, writer, value) => 
    {
      writer.Write(value.OpenString);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((Open_Unknown) obj);
    }
    public bool Equals(Open_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return OpenString == other.OpenString;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + OpenString.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("Open_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("openString = "); OpenString.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: Model.kt:74</p>
  /// </summary>
  public sealed class StructWithOpenStructField : IPrintable, IEquatable<StructWithOpenStructField>
  {
    //fields
    //public fields
    [NotNull] public OpenStructInField Inner {get; private set;}
    
    //private fields
    //primary constructor
    public StructWithOpenStructField(
      [NotNull] OpenStructInField inner
    )
    {
      if (inner == null) throw new ArgumentNullException("inner");
      
      Inner = inner;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out OpenStructInField inner)
    {
      inner = Inner;
    }
    //statics
    
    public static CtxReadDelegate<StructWithOpenStructField> Read = (ctx, reader) => 
    {
      var inner = ReadOpenStructInField(ctx, reader);
      var _result = new StructWithOpenStructField(inner);
      return _result;
    };
    public static CtxReadDelegate<OpenStructInField> ReadOpenStructInField = Polymorphic<OpenStructInField>.ReadAbstract(OpenStructInField_Unknown.Read);
    
    public static CtxWriteDelegate<StructWithOpenStructField> Write = (ctx, writer, value) => 
    {
      WriteOpenStructInField(ctx, writer, value.Inner);
    };
    public static  CtxWriteDelegate<OpenStructInField> WriteOpenStructInField = Polymorphic<OpenStructInField>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((StructWithOpenStructField) obj);
    }
    public bool Equals(StructWithOpenStructField other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Inner, other.Inner);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Inner.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("StructWithOpenStructField (");
      using (printer.IndentCookie()) {
        printer.Print("inner = "); Inner.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
}
